[{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/articles/vignette_01.html","id":"foreword","dir":"Articles","previous_headings":"","what":"Foreword","title":"Single-cell Immune Repertoire Trajectory Analysis Starting From scRepertoire","text":"Welcome dandelionR! dandelionR R package performing single-cell immune repertoire trajectory analysis, based original python implementation dandelion. provides necessary tools interface scRepertoire custom implementation absorbing markov chain pseudotime inference, inspired based palantir python package. work progress, please feel free open issue encounter problems suggestions improvement.","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/articles/vignette_01.html","id":"installation","dir":"Articles","previous_headings":"Foreword","what":"Installation","title":"Single-cell Immune Repertoire Trajectory Analysis Starting From scRepertoire","text":"can install dandelionR GitHub : standard analysis workflow R, users probably choose read VDJ data scRepertoire. vignette, demonstrate perform TCR trajectory analysis starting ‘raw’ data .e. just standard single-cell gene expression data (stored SingleCellExperiment) VDJ data (AIRR format).","code":"if (!requireNamespace(\"devtools\", quietly = TRUE)) {     install.packages(\"devtools\") } if (!requireNamespace(\"BiocManager\", quietly = TRUE)) {     install.packages(\"BiocManager\") } if (!requireNamespace(\"scater\", quietly = TRUE)) { # only for the tutorial     BiocManager::install(\"scater\") } devtools::install_github(\"tuonglab/dandelionR\", dependencies = TRUE)"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/articles/vignette_01.html","id":"installation-1","dir":"Articles","previous_headings":"Foreword","what":"Installation","title":"Single-cell Immune Repertoire Trajectory Analysis Starting From scRepertoire","text":"Install scRepertoire haven’t already.","code":"if (!requireNamespace(\"scRepertoire\", quietly = TRUE)) { # only for the tutorial     BiocManager::install(\"scRepertoire\") } # or devtools::install_github(\"ncborcherding/scRepertoire\")"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/articles/vignette_01.html","id":"load-the-required-libraries","dir":"Articles","previous_headings":"Foreword > Installation","what":"Load the required libraries","title":"Single-cell Immune Repertoire Trajectory Analysis Starting From scRepertoire","text":"","code":"library(dandelionR) library(scRepertoire) library(scater)"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/articles/vignette_01.html","id":"load-the-demo-data","dir":"Articles","previous_headings":"Foreword > Installation","what":"Load the demo data","title":"Single-cell Immune Repertoire Trajectory Analysis Starting From scRepertoire","text":"Due size limitations package, provided trimmed version demo data ~2000 cells. full dataset can found accordingly: GEX - https://developmental.cellatlas.io/fetal-immune (Lymphoid Cells) VDJ - https://github.com/zktuong/dandelion-demo-files/tree/master/dandelion_manuscript/data/dandelion-remap Check vignette example dataset starts original dandelion output associated original manuscript.","code":"data(demo_sce) data(demo_airr)"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/articles/vignette_01.html","id":"use-screpertoire-to-load-the-vdj-data","dir":"Articles","previous_headings":"Foreword > Installation","what":"Use scRepertoire to load the VDJ data","title":"Single-cell Immune Repertoire Trajectory Analysis Starting From scRepertoire","text":"trajectory analysis work , focusing main productive TCR chains. Therefore flag filterMulti = TRUE, keep selection 2 corresponding chains highest expression single barcode. details, refer scRepertoire’s documentation.","code":"contig.list <- loadContigs(input = demo_airr, format = \"AIRR\")  # Format to `scRepertoire`'s requirements and some light filtering combined.TCR <- combineTCR(contig.list,     removeNA = TRUE,     removeMulti = FALSE,     filterMulti = TRUE,     filterNonproductive = TRUE, )"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/articles/vignette_01.html","id":"merging-vdj-data-with-gene-expression-data","dir":"Articles","previous_headings":"Foreword > Installation","what":"Merging VDJ data with gene expression data","title":"Single-cell Immune Repertoire Trajectory Analysis Starting From scRepertoire","text":"Next combine gene expression data VDJ data create SingleCellExperiment object.","code":"sce <- combineExpression(combined.TCR, demo_sce)"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/articles/vignette_01.html","id":"initiate-dandelionr-workflow","dir":"Articles","previous_headings":"Foreword > Installation","what":"Initiate dandelionR workflow","title":"Single-cell Immune Repertoire Trajectory Analysis Starting From scRepertoire","text":", data ready used pseudobulk trajectory analysis workflow dandelionR. alpha-beta TCR data, set mode_option “abT”. append abT relevant columns holding VDJ gene information. going try types VDJ data e.g. BCR, set mode_option “B” instead. argument consistently set vdjPseudobulk function later. Since TCR data already filtered productive chains combineTCR, set already.productive = TRUE can keep allowed_chain_status NULL. also subset data include main T-cell types: CD8+T, CD4+T, ABT(ENTRY), DP(P)_T, DP(Q)_T. Visualise UMAP filtered data.","code":"sce <- setupVdjPseudobulk(sce,     mode_option = \"abT\",     already.productive = TRUE,     subsetby = \"anno_lvl_2_final_clean\",     groups = c(\"CD8+T\", \"CD4+T\", \"ABT(ENTRY)\", \"DP(P)_T\", \"DP(Q)_T\") ) plotUMAP(sce, color_by = \"anno_lvl_2_final_clean\")"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/articles/vignette_01.html","id":"milo-object-and-neighbourhood-graph-construction","dir":"Articles","previous_headings":"Foreword","what":"Milo object and neighbourhood graph construction","title":"Single-cell Immune Repertoire Trajectory Analysis Starting From scRepertoire","text":"use miloR create pseudobulks based gene expression data. goal construct neighbourhood graph many neighbors can sample representative neighbours form objects.","code":"library(miloR) milo_object <- Milo(sce) milo_object <- buildGraph(milo_object, k = 30, d = 20, reduced.dim = \"X_scvi\") milo_object <- makeNhoods(milo_object, reduced_dims = \"X_scvi\", d = 20, prop = 0.3)"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/articles/vignette_01.html","id":"construct-umap-on-milo-neighbor-graph","dir":"Articles","previous_headings":"Foreword > Milo object and neighbourhood graph construction","what":"Construct UMAP on milo neighbor graph","title":"Single-cell Immune Repertoire Trajectory Analysis Starting From scRepertoire","text":"can visualise milo object using UMAP.","code":"milo_object <- miloUmap(milo_object, n_neighbors = 30) plotUMAP(milo_object, color_by = \"anno_lvl_2_final_clean\", dimred = \"UMAP_knngraph\")"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/articles/vignette_01.html","id":"construct-pseudobulked-vdj-feature-space","dir":"Articles","previous_headings":"Foreword","what":"Construct pseudobulked VDJ feature space","title":"Single-cell Immune Repertoire Trajectory Analysis Starting From scRepertoire","text":"Next, construct pseudobulked VDJ feature space using neighbourhood graph constructed . also run PCA pseudobulked VDJ feature space. can visualise PCA pseudobulked VDJ feature space.","code":"pb.milo <- vdjPseudobulk(milo_object, mode_option = \"abT\", col_to_take = \"anno_lvl_2_final_clean\")  pb.milo <- runPCA(pb.milo, assay.type = \"Feature_space\", ncomponents = 20) plotPCA(pb.milo, color_by = \"anno_lvl_2_final_clean\")"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/articles/vignette_01.html","id":"tcr-trajectory-inference-using-absorbing-markov-chain","dir":"Articles","previous_headings":"Foreword","what":"TCR trajectory inference using Absorbing Markov Chain","title":"Single-cell Immune Repertoire Trajectory Analysis Starting From scRepertoire","text":"original dandelion python package, trajectory inference done using palantir package. , implement absorbing markov chain approach dandelionR infer trajectory, leveraging destiny diffusion map computation.","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/articles/vignette_01.html","id":"define-root-and-branch-tips","dir":"Articles","previous_headings":"Foreword > TCR trajectory inference using Absorbing Markov Chain","what":"Define root and branch tips","title":"Single-cell Immune Repertoire Trajectory Analysis Starting From scRepertoire","text":"","code":"# extract the PCA matrix pca <- t(as.matrix(reducedDim(pb.milo, type = \"PCA\"))) # define the CD8 terminal cell as the top-most cell and CD4 terminal cell as the bottom-most cell branch.tips <- c(which.max(pca[2, ]), which.min(pca[2, ])) names(branch.tips) <- c(\"CD8+T\", \"CD4+T\") # define the start of our trajectory as the right-most cell root <- which.max(pca[1, ])"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/articles/vignette_01.html","id":"construct-diffusion-map","dir":"Articles","previous_headings":"Foreword > TCR trajectory inference using Absorbing Markov Chain","what":"Construct diffusion map","title":"Single-cell Immune Repertoire Trajectory Analysis Starting From scRepertoire","text":"","code":"library(destiny) # Run diffusion map on the PCA dm <- DiffusionMap(t(pca), n_pcs = 10, n_eigs = 10)"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/articles/vignette_01.html","id":"compute-diffussion-pseudotime-on-diffusion-map","dir":"Articles","previous_headings":"Foreword > TCR trajectory inference using Absorbing Markov Chain","what":"Compute diffussion pseudotime on diffusion map","title":"Single-cell Immune Repertoire Trajectory Analysis Starting From scRepertoire","text":"","code":"dif.pse <- DPT(dm, tips = c(root, branch.tips), w_width = 0.1) # the root is automatically called DPT + index of the root cell DPTroot <- paste0(\"DPT\", root) # store pseudotime in milo object pb.milo$pseudotime <- dif.pse[[DPTroot]] # set the colours for pseudotime pal <- colorRampPalette(rev((RColorBrewer::brewer.pal(9, \"RdYlBu\"))))(255) plotPCA(pb.milo, color_by = \"pseudotime\") + scale_colour_gradientn(colours = pal)"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/articles/vignette_01.html","id":"markov-chain-construction-on-the-pseudobulk-vdj-feature-space","dir":"Articles","previous_headings":"Foreword > TCR trajectory inference using Absorbing Markov Chain","what":"Markov chain construction on the pseudobulk VDJ feature space","title":"Single-cell Immune Repertoire Trajectory Analysis Starting From scRepertoire","text":"","code":"pb.milo <- markovProbability(     milo = pb.milo,     diffusionmap = dm,     terminal_state = branch.tips,     root_cell = root,     pseudotime_key = \"pseudotime\",     knn = 30 )"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/articles/vignette_01.html","id":"visualising-branch-probabilities","dir":"Articles","previous_headings":"Foreword > TCR trajectory inference using Absorbing Markov Chain","what":"Visualising branch probabilities","title":"Single-cell Immune Repertoire Trajectory Analysis Starting From scRepertoire","text":"Markov chain probabilities computed, can visualise branch probabilities towards CD4+ CD8+ T-cell fate PCA plot.","code":"plotPCA(pb.milo, color_by = \"CD8+T\") + scale_color_gradientn(colors = pal) plotPCA(pb.milo, color_by = \"CD4+T\") + scale_color_gradientn(colors = pal)"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/articles/vignette_01.html","id":"transfer","dir":"Articles","previous_headings":"Foreword","what":"Transfer","title":"Single-cell Immune Repertoire Trajectory Analysis Starting From scRepertoire","text":"next step project pseudotime branch probability information pseudobulks back cell dataset. cell belong pseudobulk, removed. cell belongs multiple pseudobulk samples, value calculated weighted average corresponding values pseudobulk, weight inverse size pseudobulk.","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/articles/vignette_01.html","id":"project-pseudobulk-data-to-each-cell","dir":"Articles","previous_headings":"Foreword > Transfer","what":"Project pseudobulk data to each cell","title":"Single-cell Immune Repertoire Trajectory Analysis Starting From scRepertoire","text":"","code":"cdata <- projectPseudotimeToCell(milo_object, pb.milo, branch.tips)"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/articles/vignette_01.html","id":"visualise-the-trajectory-data-on-a-per-cell-basis","dir":"Articles","previous_headings":"Foreword > Transfer","what":"Visualise the trajectory data on a per cell basis","title":"Single-cell Immune Repertoire Trajectory Analysis Starting From scRepertoire","text":"’s ! successfully inferred trajectory T-cells dataset!","code":"plotUMAP(cdata, color_by = \"anno_lvl_2_final_clean\", dimred = \"UMAP_knngraph\") plotUMAP(cdata, color_by = \"pseudotime\", dimred = \"UMAP_knngraph\") + scale_color_gradientn(colors = pal) plotUMAP(cdata, color_by = \"CD4+T\", dimred = \"UMAP_knngraph\") + scale_color_gradientn(colors = pal) plotUMAP(cdata, color_by = \"CD8+T\", dimred = \"UMAP_knngraph\") + scale_color_gradientn(colors = pal)"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/articles/vignette_01.html","id":"session-info","dir":"Articles","previous_headings":"Foreword","what":"Session info","title":"Single-cell Immune Repertoire Trajectory Analysis Starting From scRepertoire","text":"","code":"sessionInfo() ## R version 4.4.2 (2024-10-31) ## Platform: x86_64-pc-linux-gnu ## Running under: Ubuntu 22.04.5 LTS ##  ## Matrix products: default ## BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0 ##  ## locale: ##  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        ##  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    ##  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           ## [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    ##  ## time zone: UTC ## tzcode source: system (glibc) ##  ## attached base packages: ## [1] stats4    stats     graphics  grDevices utils     datasets  methods   ## [8] base      ##  ## other attached packages: ##  [1] destiny_3.20.0              miloR_2.2.0                 ##  [3] edgeR_4.4.1                 limma_3.62.1                ##  [5] scater_1.34.0               scuttle_1.16.0              ##  [7] SingleCellExperiment_1.28.1 SummarizedExperiment_1.36.0 ##  [9] Biobase_2.66.0              GenomicRanges_1.58.0        ## [11] GenomeInfoDb_1.42.1         IRanges_2.40.1              ## [13] S4Vectors_0.44.0            BiocGenerics_0.52.0         ## [15] MatrixGenerics_1.18.0       matrixStats_1.4.1           ## [17] scRepertoire_2.2.1          ggplot2_3.5.1               ## [19] dandelionR_0.99.0           BiocStyle_2.34.0            ##  ## loaded via a namespace (and not attached): ##   [1] cubature_2.1.1          splines_4.4.2           tibble_3.2.1            ##   [4] polyclip_1.10-7         xts_0.14.1              lifecycle_1.0.4         ##   [7] globals_0.16.3          lattice_0.22-6          MASS_7.3-61             ##  [10] magrittr_2.0.3          vcd_1.4-13              sass_0.4.9              ##  [13] rmarkdown_2.29          jquerylib_0.1.4         yaml_2.3.10             ##  [16] spam_2.11-0             sp_2.1-4                cowplot_1.1.3           ##  [19] RColorBrewer_1.1-3      abind_1.4-8             zlibbioc_1.52.0         ##  [22] purrr_1.0.2             ggraph_2.2.1            hash_2.2.6.3            ##  [25] nnet_7.3-19             pracma_2.4.4            evmix_2.12              ##  [28] tweenr_2.0.3            GenomeInfoDbData_1.2.13 ggrepel_0.9.6           ##  [31] irlba_2.3.5.1           listenv_0.9.1           iNEXT_3.0.1             ##  [34] MatrixModels_0.5-3      RSpectra_0.16-2         parallelly_1.40.1       ##  [37] pkgdown_2.1.1           codetools_0.2-20        smoother_1.3            ##  [40] DelayedArray_0.32.0     ggforce_0.4.2           tidyselect_1.2.1        ##  [43] UCSC.utils_1.2.0        farver_2.1.2            ScaledMatrix_1.14.0     ##  [46] viridis_0.6.5           jsonlite_1.8.9          BiocNeighbors_2.0.1     ##  [49] e1071_1.7-16            tidygraph_1.3.1         progressr_0.15.1        ##  [52] Formula_1.2-5           survival_3.7-0          ggalluvial_0.12.5       ##  [55] systemfonts_1.1.0       tools_4.4.2             ragg_1.3.3              ##  [58] stringdist_0.9.14       Rcpp_1.0.13-1           glue_1.8.0              ##  [61] gridExtra_2.3           SparseArray_1.6.0       laeken_0.5.3            ##  [64] xfun_0.49               ranger_0.17.0           TTR_0.24.4              ##  [67] ggthemes_5.1.0          dplyr_1.1.4             withr_3.0.2             ##  [70] numDeriv_2016.8-1.1     BiocManager_1.30.25     fastmap_1.2.0           ##  [73] boot_1.3-31             bluster_1.16.0          fansi_1.0.6             ##  [76] SparseM_1.84-2          VIM_6.2.2               digest_0.6.37           ##  [79] rsvd_1.0.5              R6_2.5.1                textshaping_0.4.1       ##  [82] colorspace_2.1-1        gtools_3.9.5            utf8_1.2.4              ##  [85] tidyr_1.3.1             generics_0.1.3          hexbin_1.28.5           ##  [88] data.table_1.16.4       robustbase_0.99-4-1     class_7.3-22            ##  [91] graphlayouts_1.2.1      httr_1.4.7              htmlwidgets_1.6.4       ##  [94] S4Arrays_1.6.0          scatterplot3d_0.3-44    uwot_0.2.2              ##  [97] pkgconfig_2.0.3         gtable_0.3.6            lmtest_0.9-40           ## [100] XVector_0.46.0          htmltools_0.5.8.1       carData_3.0-5           ## [103] dotCall64_1.2           SeuratObject_5.0.2      scales_1.3.0            ## [106] knn.covertree_1.0       ggdendro_0.2.0          knitr_1.49              ## [109] rjson_0.2.23            reshape2_1.4.4          curl_6.0.1              ## [112] proxy_0.4-27            cachem_1.1.0            zoo_1.8-12              ## [115] stringr_1.5.1           parallel_4.4.2          vipor_0.4.7             ## [118] desc_1.4.3              pillar_1.9.0            grid_4.4.2              ## [121] vctrs_0.6.5             pcaMethods_1.98.0       VGAM_1.1-12             ## [124] car_3.1-3               BiocSingular_1.22.0     beachmat_2.22.0         ## [127] cluster_2.1.6           beeswarm_0.4.0          evaluate_1.0.1          ## [130] truncdist_1.0-2         cli_3.6.3               locfit_1.5-9.10         ## [133] compiler_4.4.2          rlang_1.1.4             crayon_1.5.3            ## [136] future.apply_1.11.3     labeling_0.4.3          plyr_1.8.9              ## [139] fs_1.6.5                ggbeeswarm_0.7.2        stringi_1.8.4           ## [142] viridisLite_0.4.2       BiocParallel_1.40.0     assertthat_0.2.1        ## [145] gsl_2.1-8               munsell_0.5.1           quantreg_5.99.1         ## [148] Matrix_1.7-1            RcppHNSW_0.6.0          RcppEigen_0.3.4.0.2     ## [151] patchwork_1.3.0         future_1.34.0           statmod_1.5.0           ## [154] evd_2.3-7.1             igraph_2.1.2            memoise_2.0.1           ## [157] bslib_0.8.0             DEoptimR_1.1-3-1        ggplot.multistats_1.0.1"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/articles/vignette_02.html","id":"usage","dir":"Articles","previous_headings":"","what":"Usage","title":"Single-cell Immune Repertoire Trajectory Analysis with dandelionR","text":"","code":"library(dandelionR) library(scater)"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/articles/vignette_02.html","id":"load-data","dir":"Articles","previous_headings":"","what":"Load data","title":"Single-cell Immune Repertoire Trajectory Analysis with dandelionR","text":"First, load demo data. -sampled dataset Suo et al 2024 Nature Biotechnology paper. contains 10,000 cells TCR information dimensionality reduced data (scVI) need tutorial. gene expression matrix required tutorial included demo data. show separate tutorial start data scRepertoire. set seed plots results consistent.","code":"data(sce_vdj) set.seed(100)"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/articles/vignette_02.html","id":"filter-the-data","dir":"Articles","previous_headings":"","what":"Filter the data","title":"Single-cell Immune Repertoire Trajectory Analysis with dandelionR","text":"begin, filter data extract TCR information can construct pseudobulks. colData single-cell object populated TCR information dandelion python (method: dandelion -> anndata -> anndata2ri, essentially converts AnnData object python SingleCellExperiment R), can directly use setupVdjPseudobulk function extract TCR information construct pseudobulks. , also need specify allowed_chain_status keep relevant contigs. Default allowed_chain_status NULL, keep contigs. standard R workflow starts scRepertoire, assume QC filtering already handled scRepertoire. can visualise UMAP filtered data.","code":"sce_vdj <- setupVdjPseudobulk(sce_vdj,     already.productive = FALSE,     allowed_chain_status = c(\"Single pair\", \"Extra pair\", \"Extra pair-exception\", \"Orphan VDJ\", \"Orphan VDJ-exception\") ) plotUMAP(sce_vdj, color_by = \"anno_lvl_2_final_clean\")"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/articles/vignette_02.html","id":"milo-object-and-neighbourhood-graph-construction","dir":"Articles","previous_headings":"","what":"Milo object and neighbourhood graph construction","title":"Single-cell Immune Repertoire Trajectory Analysis with dandelionR","text":"use miloR create pseudobulks based gene expression data. goal construct neighbourhood graph many neighbors can sample representative neighbours form objects.","code":"library(miloR) traj_milo <- Milo(sce_vdj) milo_object <- buildGraph(traj_milo, k = 50, d = 20, reduced.dim = \"X_scvi\") milo_object <- makeNhoods(milo_object, reduced_dims = \"X_scvi\", d = 20)"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/articles/vignette_02.html","id":"construct-umap-on-milo-neighbor-graph","dir":"Articles","previous_headings":"Milo object and neighbourhood graph construction","what":"Construct UMAP on milo neighbor graph","title":"Single-cell Immune Repertoire Trajectory Analysis with dandelionR","text":"can visualise milo object using UMAP.","code":"milo_object <- miloUmap(milo_object) plotUMAP(milo_object, color_by = \"anno_lvl_2_final_clean\", dimred = \"UMAP_knngraph\")"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/articles/vignette_02.html","id":"construct-pseudobulked-vdj-feature-space","dir":"Articles","previous_headings":"","what":"Construct pseudobulked VDJ feature space","title":"Single-cell Immune Repertoire Trajectory Analysis with dandelionR","text":"Next, construct pseudobulked VDJ feature space using neighbourhood graph constructed . also run PCA pseudobulked VDJ feature space. can visualise PCA pseudobulked VDJ feature space.","code":"pb.milo <- vdjPseudobulk(milo_object, col_to_take = \"anno_lvl_2_final_clean\")  # pbs = milo_object@nhoods pb.milo <- runPCA(pb.milo, assay.type = \"Feature_space\") plotPCA(pb.milo, color_by = \"anno_lvl_2_final_clean\")"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/articles/vignette_02.html","id":"tcr-trajectory-inference-using-absorbing-markov-chain","dir":"Articles","previous_headings":"","what":"TCR trajectory inference using Absorbing Markov Chain","title":"Single-cell Immune Repertoire Trajectory Analysis with dandelionR","text":"original dandelion python package, trajectory inference done using palantir package. , implement absorbing markov chain approach dandelionR infer trajectory, leveraging destiny diffusion map computation.","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/articles/vignette_02.html","id":"define-root-and-branch-tips","dir":"Articles","previous_headings":"TCR trajectory inference using Absorbing Markov Chain","what":"Define root and branch tips","title":"Single-cell Immune Repertoire Trajectory Analysis with dandelionR","text":"","code":"library(SingleCellExperiment)  # extract the PCA matrix pca <- t(as.matrix(reducedDim(pb.milo, type = \"PCA\"))) # define the CD8 terminal cell as the top-most cell and CD4 terminal cell as the bottom-most cell branch.tips <- c(which.max(pca[2, ]), which.min(pca[2, ])) names(branch.tips) <- c(\"CD8+T\", \"CD4+T\") # define the start of our trajectory as the right-most cell root <- which.max(pca[1, ])"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/articles/vignette_02.html","id":"construct-diffusion-map","dir":"Articles","previous_headings":"TCR trajectory inference using Absorbing Markov Chain","what":"Construct diffusion map","title":"Single-cell Immune Repertoire Trajectory Analysis with dandelionR","text":"","code":"library(destiny) # Run diffusion map on the PCA dm <- DiffusionMap(t(pca), n_pcs = 50, n_eigs = 10)"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/articles/vignette_02.html","id":"compute-diffussion-pseudotime-on-diffusion-map","dir":"Articles","previous_headings":"TCR trajectory inference using Absorbing Markov Chain","what":"Compute diffussion pseudotime on diffusion map","title":"Single-cell Immune Repertoire Trajectory Analysis with dandelionR","text":"","code":"dif.pse <- DPT(dm, tips = c(root, branch.tips), w_width = 0.1) # the root is automatically called DPT + index of the root cell DPTroot <- paste0(\"DPT\", root) # store pseudotime in milo object pb.milo$pseudotime <- dif.pse[[DPTroot]] # set the colours for pseudotime pal <- colorRampPalette(rev((RColorBrewer::brewer.pal(9, \"RdYlBu\"))))(255) plotPCA(pb.milo, color_by = \"pseudotime\") + scale_colour_gradientn(colours = pal)"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/articles/vignette_02.html","id":"markov-chain-construction-on-the-pseudobulk-vdj-feature-space","dir":"Articles","previous_headings":"TCR trajectory inference using Absorbing Markov Chain","what":"Markov chain construction on the pseudobulk VDJ feature space","title":"Single-cell Immune Repertoire Trajectory Analysis with dandelionR","text":"","code":"pb.milo <- markovProbability(     milo = pb.milo,     diffusionmap = dm,     terminal_state = branch.tips,     root_cell = root,     pseudotime_key = \"pseudotime\" )"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/articles/vignette_02.html","id":"visualising-branch-probabilities","dir":"Articles","previous_headings":"TCR trajectory inference using Absorbing Markov Chain","what":"Visualising branch probabilities","title":"Single-cell Immune Repertoire Trajectory Analysis with dandelionR","text":"Markov chain probabilities computed, can visualise branch probabilities towards CD4+ CD8+ T-cell fate PCA plot.","code":"plotPCA(pb.milo, color_by = \"CD8+T\") + scale_color_gradientn(colors = pal) plotPCA(pb.milo, color_by = \"CD4+T\") + scale_color_gradientn(colors = pal)"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/articles/vignette_02.html","id":"transfer","dir":"Articles","previous_headings":"","what":"Transfer","title":"Single-cell Immune Repertoire Trajectory Analysis with dandelionR","text":"next step project pseudotime branch probability information pseudobulks back cell dataset. cell belong pseudobulk, removed. cell belongs multiple pseudobulk samples, value calculated weighted average corresponding values pseudobulk, weight inverse size pseudobulk.","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/articles/vignette_02.html","id":"project-pseudobulk-data-to-each-cell","dir":"Articles","previous_headings":"Transfer","what":"Project pseudobulk data to each cell","title":"Single-cell Immune Repertoire Trajectory Analysis with dandelionR","text":"","code":"cdata <- projectPseudotimeToCell(milo_object, pb.milo, branch.tips)"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/articles/vignette_02.html","id":"visualise-the-trajectory-data-on-a-per-cell-basis","dir":"Articles","previous_headings":"Transfer","what":"Visualise the trajectory data on a per cell basis","title":"Single-cell Immune Repertoire Trajectory Analysis with dandelionR","text":"’s ! successfully inferred trajectory T-cells dataset!","code":"plotUMAP(cdata, color_by = \"anno_lvl_2_final_clean\", dimred = \"UMAP_knngraph\") plotUMAP(cdata, color_by = \"pseudotime\", dimred = \"UMAP_knngraph\") + scale_color_gradientn(colors = pal) plotUMAP(cdata, color_by = \"CD4+T\", dimred = \"UMAP_knngraph\") + scale_color_gradientn(colors = pal) plotUMAP(cdata, color_by = \"CD8+T\", dimred = \"UMAP_knngraph\") + scale_color_gradientn(colors = pal)"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/articles/vignette_02.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session info","title":"Single-cell Immune Repertoire Trajectory Analysis with dandelionR","text":"","code":"sessionInfo() ## R version 4.4.2 (2024-10-31) ## Platform: x86_64-pc-linux-gnu ## Running under: Ubuntu 22.04.5 LTS ##  ## Matrix products: default ## BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0 ##  ## locale: ##  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        ##  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    ##  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           ## [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    ##  ## time zone: UTC ## tzcode source: system (glibc) ##  ## attached base packages: ## [1] stats4    stats     graphics  grDevices utils     datasets  methods   ## [8] base      ##  ## other attached packages: ##  [1] destiny_3.20.0              miloR_2.2.0                 ##  [3] edgeR_4.4.1                 limma_3.62.1                ##  [5] scater_1.34.0               ggplot2_3.5.1               ##  [7] scuttle_1.16.0              SingleCellExperiment_1.28.1 ##  [9] SummarizedExperiment_1.36.0 Biobase_2.66.0              ## [11] GenomicRanges_1.58.0        GenomeInfoDb_1.42.1         ## [13] IRanges_2.40.1              S4Vectors_0.44.0            ## [15] BiocGenerics_0.52.0         MatrixGenerics_1.18.0       ## [17] matrixStats_1.4.1           dandelionR_0.99.0           ## [19] BiocStyle_2.34.0            ##  ## loaded via a namespace (and not attached): ##   [1] vcd_1.4-13              RColorBrewer_1.1-3      jsonlite_1.8.9          ##   [4] magrittr_2.0.3          ggbeeswarm_0.7.2        farver_2.1.2            ##   [7] rmarkdown_2.29          fs_1.6.5                zlibbioc_1.52.0         ##  [10] ragg_1.3.3              vctrs_0.6.5             memoise_2.0.1           ##  [13] htmltools_0.5.8.1       S4Arrays_1.6.0          curl_6.0.1              ##  [16] BiocNeighbors_2.0.1     SparseArray_1.6.0       Formula_1.2-5           ##  [19] TTR_0.24.4              sass_0.4.9              pracma_2.4.4            ##  [22] bslib_0.8.0             htmlwidgets_1.6.4       desc_1.4.3              ##  [25] zoo_1.8-12              cachem_1.1.0            igraph_2.1.2            ##  [28] lifecycle_1.0.4         pkgconfig_2.0.3         rsvd_1.0.5              ##  [31] Matrix_1.7-1            R6_2.5.1                fastmap_1.2.0           ##  [34] GenomeInfoDbData_1.2.13 digest_0.6.37           numDeriv_2016.8-1.1     ##  [37] pcaMethods_1.98.0       colorspace_2.1-1        patchwork_1.3.0         ##  [40] RSpectra_0.16-2         irlba_2.3.5.1           textshaping_0.4.1       ##  [43] beachmat_2.22.0         labeling_0.4.3          fansi_1.0.6             ##  [46] httr_1.4.7              polyclip_1.10-7         abind_1.4-8             ##  [49] compiler_4.4.2          proxy_0.4-27            withr_3.0.2             ##  [52] BiocParallel_1.40.0     carData_3.0-5           viridis_0.6.5           ##  [55] hexbin_1.28.5           knn.covertree_1.0       ggforce_0.4.2           ##  [58] MASS_7.3-61             DelayedArray_0.32.0     scatterplot3d_0.3-44    ##  [61] bluster_1.16.0          gtools_3.9.5            tools_4.4.2             ##  [64] lmtest_0.9-40           ranger_0.17.0           vipor_0.4.7             ##  [67] ggplot.multistats_1.0.1 beeswarm_0.4.0          nnet_7.3-19             ##  [70] glue_1.8.0              grid_4.4.2              cluster_2.1.6           ##  [73] generics_0.1.3          gtable_0.3.6            class_7.3-22            ##  [76] tidyr_1.3.1             data.table_1.16.4       BiocSingular_1.22.0     ##  [79] tidygraph_1.3.1         ScaledMatrix_1.14.0     sp_2.1-4                ##  [82] car_3.1-3               utf8_1.2.4              XVector_0.46.0          ##  [85] ggrepel_0.9.6           pillar_1.9.0            stringr_1.5.1           ##  [88] spam_2.11-0             RcppHNSW_0.6.0          VIM_6.2.2               ##  [91] robustbase_0.99-4-1     dplyr_1.1.4             tweenr_2.0.3            ##  [94] lattice_0.22-6          smoother_1.3            tidyselect_1.2.1        ##  [97] locfit_1.5-9.10         knitr_1.49              gridExtra_2.3           ## [100] xfun_0.49               graphlayouts_1.2.1      statmod_1.5.0           ## [103] DEoptimR_1.1-3-1        stringi_1.8.4           UCSC.utils_1.2.0        ## [106] yaml_2.3.10             boot_1.3-31             evaluate_1.0.1          ## [109] codetools_0.2-20        laeken_0.5.3            RcppEigen_0.3.4.0.2     ## [112] ggraph_2.2.1            tibble_3.2.1            BiocManager_1.30.25     ## [115] cli_3.6.3               uwot_0.2.2              systemfonts_1.1.0       ## [118] munsell_0.5.1           jquerylib_0.1.4         Rcpp_1.0.13-1           ## [121] parallel_4.4.2          pkgdown_2.1.1           dotCall64_1.2           ## [124] ggthemes_5.1.0          viridisLite_0.4.2       xts_0.14.1              ## [127] scales_1.3.0            e1071_1.7-16            purrr_1.0.2             ## [130] crayon_1.5.3            rlang_1.1.4             cowplot_1.1.3"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Jiawei Yu. Author. Nicholas Borcherding. Author. Kelvin Tuong. Author, maintainer.","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Yu J, Borcherding N, Tuong ZK. DandelionR: Single-cell immune repertoire trajectory analysis R. Suo C, Polanski K, Dann E, Lindeboom RGH, Vilarrasa-Blasi R, Vento-Tormo R, Haniffa M, Meyer KB, Dratva LM, Tuong ZK, Clatworthy MR, Teichmann SA. Dandelion uses single-cell adaptive immune receptor repertoire explore lymphocyte developmental origins. Nat Biotechnol. 2024;42(1):40-51. doi:10.1038/s41587-023-01734-7.","code":"@Article{,   title = {DandelionR: Single-cell immune repertoire trajectory analysis in R},   author = {Jiawei Yu and Nicholas Borcherding and Zewen Kelvin Tuong},   journal = {TBC},   year = {2025}, } @Article{,   title = {Dandelion uses the single-cell adaptive immune receptor repertoire to explore lymphocyte developmental origins},   author = {Chenqu Suo and Krzysztof Polanski and Emma Dann and Rik G.H. Lindeboom and Roser Vilarrasa-Blasi and Roser Vento-Tormo and Muzlifah Haniffa and Kerstin B. Meyer and Lisa M. Dratva and Zewen Kelvin Tuong and Menna R. Clatworthy and Sarah A. Teichmann},   journal = {Nature Biotechnology},   volume = {42},   year = {2024},   publisher = {Nature Publishing Group},   doi = {10.1038/s41587-023-01734-7},   url = {https://www.nature.com/articles/s41587-023-01734-7}, }"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/index.html","id":"dandelionr","dir":"","previous_headings":"","what":"Single-cell Immune Repertoire Trajectory Analysis in R","title":"Single-cell Immune Repertoire Trajectory Analysis in R","text":"Welcome dandelionR! dandelionR R package performing single-cell immune repertoire trajectory analysis, based original python implementation dandelion. provides necessary tools interface scRepertoire custom implementation absorbing markov chain pseudotime inference, inspired based palantir python package.","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Single-cell Immune Repertoire Trajectory Analysis in R","text":"can install dandelionR GitHub :","code":"if (!requireNamespace(\"devtools\", quietly = TRUE))     install.packages(\"devtools\") if (!requireNamespace(\"BiocManager\", quietly = TRUE))     install.packages(\"BiocManager\") devtools::install_github('tuonglab/dandelionR', dependencies = TRUE)"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/index.html","id":"quick-start","dir":"","previous_headings":"","what":"Quick Start","title":"Single-cell Immune Repertoire Trajectory Analysis in R","text":"work progress, please feel free open issue encounter problems suggestions improvement.","code":"library(dandelionR)"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Single-cell Immune Repertoire Trajectory Analysis in R","text":"use dandelionR work, please cite original dandelion paper: Placeholder Bioconductor citation.","code":"Suo, C. et al. Dandelion uses the single-cell adaptive immune receptor repertoire to explore lymphocyte developmental origins. Nat. Biotechnol. 42, 40-51 (2024). https://doi.org:10.1038/s41587-023-01734-7 Yu, J., Borcherding, N. & Tuong, Z.K.. (2024) DandelionR: Single-cell immune repertoire trajectory analysis in R. R package version 0.99.0."},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/chainAssign.html","id":null,"dir":"Reference","previous_headings":"","what":"Assign the V(D)J gene to the right chain. — chainAssign","title":"Assign the V(D)J gene to the right chain. — chainAssign","text":"Assign V(D)J gene right chain.","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/chainAssign.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assign the V(D)J gene to the right chain. — chainAssign","text":"","code":"chainAssign(vec, num)"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/chainAssign.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assign the V(D)J gene to the right chain. — chainAssign","text":"vec vector V(D)J genes assign right chain. num number genes return. 2(vj) 3(vdj)","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/chainAssign.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Assign the V(D)J gene to the right chain. — chainAssign","text":"list contain vector VJ + VDJ cell input","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/demo_airr.html","id":null,"dir":"Reference","previous_headings":"","what":"Example AIRR Dataset for V(D)J Analysis — demo_airr","title":"Example AIRR Dataset for V(D)J Analysis — demo_airr","text":"demo_airr object list AIRR data frames -sampled demo dataset derived Suo et al., 2024, Nature Biotechnology. dataset used vignettes demonstrate workflows V(D)J analysis. details, see original publication https://www.nature.com/articles/s41587-023-01734-7. original files available https://github.com/zktuong/dandelion-demo-files.","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/demo_airr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example AIRR Dataset for V(D)J Analysis — demo_airr","text":"","code":"data(demo_airr)"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/demo_airr.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example AIRR Dataset for V(D)J Analysis — demo_airr","text":"SingleCellExperiment object following slots: list List DataFrames containing standardised AIRR data sample. information AIRR rearrangements, see AIRR Community standards https://docs.airr-community.org/en/stable/datarep/rearrangements.html.","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/demo_airr.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Example AIRR Dataset for V(D)J Analysis — demo_airr","text":"Suo et al., 2024, Nature Biotechnology. https://www.nature.com/articles/s41587-023-01734-7.","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/demo_airr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Example AIRR Dataset for V(D)J Analysis — demo_airr","text":"","code":"data(demo_airr)"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/demo_sce.html","id":null,"dir":"Reference","previous_headings":"","what":"Example SCE Dataset that does not contain V(D)J information — demo_sce","title":"Example SCE Dataset that does not contain V(D)J information — demo_sce","text":"demo_sce object -sampled demo dataset derived Suo et al., 2024, Nature Biotechnology. dataset used vignettes demonstrate workflows V(D)J analysis. details, see original publication https://www.nature.com/articles/s41587-023-01734-7. original Lymphoid cells data available url{https://developmental.cellatlas.io/fetal-immune}.","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/demo_sce.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example SCE Dataset that does not contain V(D)J information — demo_sce","text":"","code":"data(demo_sce)"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/demo_sce.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example SCE Dataset that does not contain V(D)J information — demo_sce","text":"SingleCellExperiment object following slots: colData minimall DataFrame containing metadata sample, corresponding obs AnnData (Python). following columns relevant vignette usage: anno_lvl_2_final_clean Cell type annotations. int_colData DataFrame containing additional assay metadata important analysis. Includes: X_scvi: dimensionality reduction matrix scVI model. UMAP: UMAP reduction matrix.","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/demo_sce.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Example SCE Dataset that does not contain V(D)J information — demo_sce","text":"Suo et al., 2024, Nature Biotechnology. https://www.nature.com/articles/s41587-023-01734-7.","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/demo_sce.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Example SCE Dataset that does not contain V(D)J information — demo_sce","text":"","code":"data(demo_sce)"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/differentiationProbabilities.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Branch Probabilities Using Markov Chain — differentiationProbabilities","title":"Compute Branch Probabilities Using Markov Chain — differentiationProbabilities","text":"function calculates branch probabilities differentiation trajectories based Markov chain constructed waypoint data pseudotime ordering.","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/differentiationProbabilities.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Branch Probabilities Using Markov Chain — differentiationProbabilities","text":"","code":"differentiationProbabilities(   wp_data,   terminal_states = NULL,   knn = 30L,   pseudotime,   waypoints )"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/differentiationProbabilities.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Branch Probabilities Using Markov Chain — differentiationProbabilities","text":"wp_data multi-scale data matrix data frame representing waypoints. terminal_states Integer vector. Indices terminal states. Default NULL. knn Integer. Number nearest neighbors graph construction. Default 30L. pseudotime Numeric vector. Pseudotime ordering cells. waypoints Integer vector. Indices selected waypoints used construct Markov chain.","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/differentiationProbabilities.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Branch Probabilities Using Markov Chain — differentiationProbabilities","text":"numeric matrix data frame containing branch probabilities waypoint.","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/dot-classCheck.html","id":null,"dir":"Reference","previous_headings":"","what":".classCheck — .classCheck","title":".classCheck — .classCheck","text":"check whether input correct class","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/dot-classCheck.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":".classCheck — .classCheck","text":"","code":".classCheck(input, must)"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/dot-classCheck.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":".classCheck — .classCheck","text":"input input need check must type need","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/dot-classCheck.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":".classCheck — .classCheck","text":"whether input correct class","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/dot-collapse_nested_list.html","id":null,"dir":"Reference","previous_headings":"","what":"Collapse a nested list — .collapse_nested_list","title":"Collapse a nested list — .collapse_nested_list","text":"Collapse nested list","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/dot-collapse_nested_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Collapse a nested list — .collapse_nested_list","text":"","code":".collapse_nested_list(input_list)"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/dot-collapse_nested_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Collapse a nested list — .collapse_nested_list","text":"input_list input nested list.","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/dot-collapse_nested_list.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Collapse a nested list — .collapse_nested_list","text":"collapsed list","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/dot-constructMarkovChain.html","id":null,"dir":"Reference","previous_headings":"","what":".constructMarkovChain — .constructMarkovChain","title":".constructMarkovChain — .constructMarkovChain","text":"Markov chain construction","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/dot-constructMarkovChain.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":".constructMarkovChain — .constructMarkovChain","text":"","code":".constructMarkovChain(wp_data, knn., pseudotime, waypoints)"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/dot-constructMarkovChain.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":".constructMarkovChain — .constructMarkovChain","text":"wp_data Multi scale data waypoints knn. Number nearest neighbors graph construction pseudotime pseudotime ordering cells waypoints integer vector, index selected waypoint used construct markov chain","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/dot-constructMarkovChain.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":".constructMarkovChain — .constructMarkovChain","text":"transition matrix markov chain","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/dot-determineMultiscaleSpace.html","id":null,"dir":"Reference","previous_headings":"","what":".determineMultiscaleSpace — .determineMultiscaleSpace","title":".determineMultiscaleSpace — .determineMultiscaleSpace","text":".determineMultiscaleSpace","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/dot-determineMultiscaleSpace.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":".determineMultiscaleSpace — .determineMultiscaleSpace","text":"","code":".determineMultiscaleSpace(diffusionmap, n_eigs = NULL)"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/dot-determineMultiscaleSpace.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":".determineMultiscaleSpace — .determineMultiscaleSpace","text":"diffusionmap DiffusionMap object n_eigs integer, default NULL. Number eigen vectors use. specified, number eigen vectors determined using eigen gap.","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/dot-determineMultiscaleSpace.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":".determineMultiscaleSpace — .determineMultiscaleSpace","text":"dataframe","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/dot-filterCells.html","id":null,"dir":"Reference","previous_headings":"","what":".filterCells — .filterCells","title":".filterCells — .filterCells","text":"Helper function identifies filter_pattern hits determined column sce, either removes offeending cells masks matched values uniform value '(column's name)_missing'","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/dot-filterCells.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":".filterCells — .filterCells","text":"","code":".filterCells(   sce,   col_n,   filter_pattern = \",|None|No_contig\",   remove_missing = TRUE )"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/dot-filterCells.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":".filterCells — .filterCells","text":"sce SingleCellExperiment object, adata python data combineTCR， contain vdj seq col_n mode extraction V(D)J genes. filter_pattern character string, optional ',|None|No_contig' default remove_missing bool, True default TRUE, remove cells contigs matching filter object. FALSE, mask uniform value dependent column name.","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/dot-filterCells.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":".filterCells — .filterCells","text":"filtered SingleCellExperiment object according parameter.","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/dot-getPbs.html","id":null,"dir":"Reference","previous_headings":"","what":".getPbs — .getPbs","title":".getPbs — .getPbs","text":"Helper function ensure cells pseudobulks matrix can use pseudobulking.","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/dot-getPbs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":".getPbs — .getPbs","text":"","code":".getPbs(pbs, col_to_bulk, milo)"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/dot-getPbs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":".getPbs — .getPbs","text":"pbs pbs parameter provided vdjPseudobulk(),  cells pseudobulks matrix NULL col_to_bulk col_to_bulk parameter provided vdjPseudobulk(), column's name colData milo milo SingleCellExperiment object","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/dot-getPbs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":".getPbs — .getPbs","text":"cell x pseudobulk matrix","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/dot-getPbsCol.html","id":null,"dir":"Reference","previous_headings":"","what":".getPbsCol — .getPbsCol","title":".getPbsCol — .getPbsCol","text":"Helper function create new pseudobulk object's coldata.","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/dot-getPbsCol.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":".getPbsCol — .getPbsCol","text":"","code":".getPbsCol(pbs, col_to_take, milo)"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/dot-getPbsCol.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":".getPbsCol — .getPbsCol","text":"pbs dgeMatrix, cell x pseudobulk binary matrix col_to_take character vector, names colData milo need processed milo Milo SingleCellExperiment object","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/dot-getPbsCol.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":".getPbsCol — .getPbsCol","text":"pbs_col, DataFrame passed new SingleCellExperiment object colData vdj x pseudobulk assays","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/dot-maxMinSampling.html","id":null,"dir":"Reference","previous_headings":"","what":".maxMinSampling — .maxMinSampling","title":".maxMinSampling — .maxMinSampling","text":"function max min sampling waypoints","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/dot-maxMinSampling.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":".maxMinSampling — .maxMinSampling","text":"","code":".maxMinSampling(data, num_waypoints)"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/dot-maxMinSampling.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":".maxMinSampling — .maxMinSampling","text":"data data matrix along sample waypoints, usually diffusion components num_waypoints number waypoints sample","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/dot-maxMinSampling.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":".maxMinSampling — .maxMinSampling","text":"Series reprenting sampled waypoints","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/dot-minMaxScale.html","id":null,"dir":"Reference","previous_headings":"","what":"minMaxScale — .minMaxScale","title":"minMaxScale — .minMaxScale","text":"scale value range 0 1","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/dot-minMaxScale.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"minMaxScale — .minMaxScale","text":"","code":".minMaxScale(data)"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/dot-minMaxScale.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"minMaxScale — .minMaxScale","text":"data dataframe need scale","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/dot-minMaxScale.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"minMaxScale — .minMaxScale","text":"scaled value","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/dot-terminalStateFromMarkovChain.html","id":null,"dir":"Reference","previous_headings":"","what":".terminalStateFromMarkovChain — .terminalStateFromMarkovChain","title":".terminalStateFromMarkovChain — .terminalStateFromMarkovChain","text":".terminalStateFromMarkovChain","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/dot-terminalStateFromMarkovChain.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":".terminalStateFromMarkovChain — .terminalStateFromMarkovChain","text":"","code":".terminalStateFromMarkovChain(Transmat, wp_data, pseudotime, waypoints)"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/dot-terminalStateFromMarkovChain.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":".terminalStateFromMarkovChain — .terminalStateFromMarkovChain","text":"Transmat Transition matrix wp_data Multi scale data waypoints pseudotime numeric vector, pseudotime pseudobulk waypoints integer vector, waypoint selected construct markov chain.","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/dot-terminalStateFromMarkovChain.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":".terminalStateFromMarkovChain — .terminalStateFromMarkovChain","text":"terminal_state","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/dot-typeCheck.html","id":null,"dir":"Reference","previous_headings":"","what":".typeCheck — .typeCheck","title":".typeCheck — .typeCheck","text":"check whether input correct type","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/dot-typeCheck.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":".typeCheck — .typeCheck","text":"","code":".typeCheck(input, must)"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/dot-typeCheck.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":".typeCheck — .typeCheck","text":"input input need check must type need","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/dot-typeCheck.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":".typeCheck — .typeCheck","text":"whether input correct type","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/formatVdj.html","id":null,"dir":"Reference","previous_headings":"","what":"Change the format of splitCTgene output. — formatVdj","title":"Change the format of splitCTgene output. — formatVdj","text":"Change format splitCTgene output.","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/formatVdj.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Change the format of splitCTgene output. — formatVdj","text":"","code":"formatVdj(gene_list)"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/formatVdj.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Change the format of splitCTgene output. — formatVdj","text":"gene_list list containing output splitCTgene.","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/formatVdj.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Change the format of splitCTgene output. — formatVdj","text":"list contain vector VJ + VDJ information cell input","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/markovProbability.html","id":null,"dir":"Reference","previous_headings":"","what":"Markov Chain Construction and Probability Calculation — markovProbability","title":"Markov Chain Construction and Probability Calculation — markovProbability","text":"function preprocesses data, constructs Markov chain, calculates transition probabilities based pseudotime information.","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/markovProbability.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Markov Chain Construction and Probability Calculation — markovProbability","text":"","code":"markovProbability(   milo,   diffusionmap,   terminal_state,   root_cell,   knn = 30L,   diffusiontime = NULL,   pseudotime_key = \"pseudotime\",   scale_components = TRUE,   num_waypoints = 500 )"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/markovProbability.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Markov Chain Construction and Probability Calculation — markovProbability","text":"milo Milo SingleCellExperiment object. object pseudotime stored colData, used calculate probabilities. pseudotime available milo, takes precedence value provided diffusiontime parameter. diffusionmap DiffusionMap object corresponding milo object. Used Markov chain construction. terminal_state Integer. index terminal state Markov chain. root_cell Integer. index root state Markov chain. knn Integer. number nearest neighbors graph construction. Default 30L. diffusiontime Numeric vector. pseudotime stored milo, parameter can used provide pseudotime values function. pseudotime_key Character. name column colData contains inferred pseudotime. scale_components Logical. TRUE, components scaled constructing Markov chain. Default FALSE. num_waypoints Integer. number waypoints sample constructing Markov chain. Default 500L.","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/markovProbability.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Markov Chain Construction and Probability Calculation — markovProbability","text":"milo SinglCellExperiment object pseudotime, probabilities colData","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/markovProbability.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Markov Chain Construction and Probability Calculation — markovProbability","text":"","code":"data(sce_vdj) sce_vdj <- setupVdjPseudobulk(sce_vdj,     already.productive = FALSE,     allowed_chain_status = c(\"Single pair\", \"Extra pair\") ) #> Checking productivity from productive_abT_VDJ, productive_abT_VJ ... #> 7279 of cells filtered #> checking allowed chain status... #> 12 of cells filtered #> VDJ data extraction begin: #> Parameter extract_cols do not provided, automatically geneterate colnames for extraction. #> Detect whether colData v_call_abT_VDJ, d_call_abT_VDJ, j_call_abT_VDJ, v_call_abT_VJ, j_call_abT_VJ already exist... #> Extract main TCR from v_call_abT_VDJ, d_call_abT_VDJ, j_call_abT_VDJ, v_call_abT_VJ, j_call_abT_VJ ... #> Complete. #> Filtering cells from v_call_abT_VDJ_main, j_call_abT_VDJ_main, v_call_abT_VJ_main, j_call_abT_VJ_main ... #> 63 of cells filtered #> 2646 of cells remain. # Build Milo Object set.seed(100) milo_object <- miloR::Milo(sce_vdj) milo_object <- miloR::buildGraph(milo_object, k = 50, d = 20, reduced.dim = \"X_scvi\") #> Constructing kNN graph with k:50 milo_object <- miloR::makeNhoods(milo_object, reduced_dims = \"X_scvi\", d = 20) #> Checking valid object #> Running refined sampling with reduced_dim  # Construct Pseudobulked VDJ Feature Space pb.milo <- vdjPseudobulk(milo_object, col_to_take = \"anno_lvl_2_final_clean\") pb.milo <- scater::runPCA(pb.milo, assay.type = \"Feature_space\")  # Define root and branch tips pca <- t(as.matrix(SingleCellExperiment::reducedDim(pb.milo, type = \"PCA\"))) branch.tips <- c(189, 198) # which.min(pca[, 2]) and which.max(pca[, 2]) names(branch.tips) <- c(\"CD8+T\", \"CD4+T\") root <- 177 # which.max(pca[, 1])  # Construct Diffusion Map dm <- destiny::DiffusionMap(t(pca), n_pcs = 50, n_eigs = 10) #> 'as(<dsCMatrix>, \"dgTMatrix\")' is deprecated. #> Use 'as(as(., \"generalMatrix\"), \"TsparseMatrix\")' instead. #> See help(\"Deprecated\") and help(\"Matrix-deprecated\"). dif.pse <- destiny::DPT(dm, tips = c(root, branch.tips), w_width = 0.1)  # Markov Chain Construction pb.milo <- markovProbability(     milo = pb.milo,     diffusionmap = dm,     diffusiontime = dif.pse[[paste0(\"DPT\", root)]],     terminal_state = branch.tips,     root_cell = root,     pseudotime_key = \"pseudotime\" ) #> Sampling and flocking waypoints... #> Markov chain construction... #> Computing fundamental matrix and absorption probabilities... #> Project probabilites from waypoints to each pseudobulk..."},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/miloUmap.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform UMAP on the Adjacency Matrix of a Milo Object — miloUmap","title":"Perform UMAP on the Adjacency Matrix of a Milo Object — miloUmap","text":"function uses uwot::umap perform UMAP dimensionality reduction adjacency matrix KNN graph Milo object.","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/miloUmap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform UMAP on the Adjacency Matrix of a Milo Object — miloUmap","text":"","code":"miloUmap(   milo,   slot_name = \"UMAP_knngraph\",   n_neighbors = 50L,   metric = \"euclidean\",   min_dist = 0.3,   ... )"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/miloUmap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Perform UMAP on the Adjacency Matrix of a Milo Object — miloUmap","text":"milo milo object knn graph needed conduct umap . slot_name character, default 'UMAP_knngraph'. slot name reduceDim result store n_neighbors integer, default 50L. size local neighborhood (terms number neighboring sample points) used manifold approximation. , goal create large enough neighborhoods capture local manifold structure allow hypersampling. metric character, default 'euclidean' choice metric used measure distance find nearest neighbors. Default 'euclidean'. min_dist numeric, default 0.3 minimum distance points low dimensional space ... parameters passed uwot::umap","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/miloUmap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Perform UMAP on the Adjacency Matrix of a Milo Object — miloUmap","text":"milo object umap reduction","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/miloUmap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Perform UMAP on the Adjacency Matrix of a Milo Object — miloUmap","text":"","code":"data(sce_vdj) sce_vdj <- setupVdjPseudobulk(sce_vdj,     already.productive = FALSE,     allowed_chain_status = c(\"Single pair\", \"Extra pair\") ) #> Checking productivity from productive_abT_VDJ, productive_abT_VJ ... #> 7279 of cells filtered #> checking allowed chain status... #> 12 of cells filtered #> VDJ data extraction begin: #> Parameter extract_cols do not provided, automatically geneterate colnames for extraction. #> Detect whether colData v_call_abT_VDJ, d_call_abT_VDJ, j_call_abT_VDJ, v_call_abT_VJ, j_call_abT_VJ already exist... #> Extract main TCR from v_call_abT_VDJ, d_call_abT_VDJ, j_call_abT_VDJ, v_call_abT_VJ, j_call_abT_VJ ... #> Complete. #> Filtering cells from v_call_abT_VDJ_main, j_call_abT_VDJ_main, v_call_abT_VJ_main, j_call_abT_VJ_main ... #> 63 of cells filtered #> 2646 of cells remain. # Build Milo Object milo_object <- miloR::Milo(sce_vdj) milo_object <- miloR::buildGraph(milo_object, k = 50, d = 20, reduced.dim = \"X_scvi\") #> Constructing kNN graph with k:50 milo_object <- miloR::makeNhoods(milo_object, reduced_dims = \"X_scvi\", d = 20) #> Checking valid object #> Running refined sampling with reduced_dim  # Construct UMAP on Milo Neighbor Graph milo_object <- miloUmap(milo_object)"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/projectProbability.html","id":null,"dir":"Reference","previous_headings":"","what":"Project Probabilities from Markov Chain to Pseudobulks — projectProbability","title":"Project Probabilities from Markov Chain to Pseudobulks — projectProbability","text":"function projects probabilities calculated Markov chain onto pseudobulk based diffusion distance matrix.","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/projectProbability.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Project Probabilities from Markov Chain to Pseudobulks — projectProbability","text":"","code":"projectProbability(diffusionmap, waypoints, probabilities, t = 1)"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/projectProbability.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Project Probabilities from Markov Chain to Pseudobulks — projectProbability","text":"diffusionmap diffusion map, used reconstruct diffustion distance matrix waypoints Integer vector. Indices waypoints used Markov chain. probabilities Numeric vector. Probabilities associated waypoints, calculated Markov chain. t Numeric. diffusion time used projection.","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/projectProbability.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Project Probabilities from Markov Chain to Pseudobulks — projectProbability","text":"pseudobulk's probabilites","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/projectPseudotimeToCell.html","id":null,"dir":"Reference","previous_headings":"","what":"Project Pseudotime and Branch Probabilities to Single Cells — projectPseudotimeToCell","title":"Project Pseudotime and Branch Probabilities to Single Cells — projectPseudotimeToCell","text":"function projects pseudotime branch probabilities pseudobulk (pb.milo) data single-cell resolution (milo). results stored colData milo object.","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/projectPseudotimeToCell.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Project Pseudotime and Branch Probabilities to Single Cells — projectPseudotimeToCell","text":"","code":"projectPseudotimeToCell(   milo,   pb_milo,   term_states,   pseudotime_key = \"pseudotime\",   suffix = \"\" )"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/projectPseudotimeToCell.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Project Pseudotime and Branch Probabilities to Single Cells — projectPseudotimeToCell","text":"milo SingleCellExperiment Milo object. Represents single-cell data pseudotime branch probabilities projected. pb_milo pseudobulk Milo object. Contains aggregated branch probabilities pseudotime information transferred single cells. term_states named vector terminal states, branch probabilities transferred. names correspond branches interest. pseudotime_key Character. column name colData pb_milo contains  pseudotime information used markovProbability function. Default \"pseudotime\". suffix Character. suffix added new column names colData. Default empty string ('').","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/projectPseudotimeToCell.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Project Pseudotime and Branch Probabilities to Single Cells — projectPseudotimeToCell","text":"subset milo SingleCellExperiment object cell belong neighbourhood removed projected pseudotime information stored colData","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/projectPseudotimeToCell.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Project Pseudotime and Branch Probabilities to Single Cells — projectPseudotimeToCell","text":"","code":"data(sce_vdj) sce_vdj <- setupVdjPseudobulk(sce_vdj,     already.productive = FALSE,     allowed_chain_status = c(\"Single pair\", \"Extra pair\") ) #> Checking productivity from productive_abT_VDJ, productive_abT_VJ ... #> 7279 of cells filtered #> checking allowed chain status... #> 12 of cells filtered #> VDJ data extraction begin: #> Parameter extract_cols do not provided, automatically geneterate colnames for extraction. #> Detect whether colData v_call_abT_VDJ, d_call_abT_VDJ, j_call_abT_VDJ, v_call_abT_VJ, j_call_abT_VJ already exist... #> Extract main TCR from v_call_abT_VDJ, d_call_abT_VDJ, j_call_abT_VDJ, v_call_abT_VJ, j_call_abT_VJ ... #> Complete. #> Filtering cells from v_call_abT_VDJ_main, j_call_abT_VDJ_main, v_call_abT_VJ_main, j_call_abT_VJ_main ... #> 63 of cells filtered #> 2646 of cells remain. # Build Milo Object set.seed(100) milo_object <- miloR::Milo(sce_vdj) milo_object <- miloR::buildGraph(milo_object, k = 50, d = 20, reduced.dim = \"X_scvi\") #> Constructing kNN graph with k:50 milo_object <- miloR::makeNhoods(milo_object, reduced_dims = \"X_scvi\", d = 20) #> Checking valid object #> Running refined sampling with reduced_dim  # Construct Pseudobulked VDJ Feature Space pb.milo <- vdjPseudobulk(milo_object, col_to_take = \"anno_lvl_2_final_clean\") pb.milo <- scater::runPCA(pb.milo, assay.type = \"Feature_space\")  # Define root and branch tips pca <- t(as.matrix(SingleCellExperiment::reducedDim(pb.milo, type = \"PCA\"))) branch.tips <- c(189, 198) # which.min(pca[, 2]) and which.max(pca[, 2]) names(branch.tips) <- c(\"CD8+T\", \"CD4+T\") root <- 177 # which.max(pca[, 1])  # Construct Diffusion Map dm <- destiny::DiffusionMap(t(pca), n_pcs = 50, n_eigs = 10) dif.pse <- destiny::DPT(dm, tips = c(root, branch.tips), w_width = 0.1)  # Markov Chain Construction pb.milo <- markovProbability(     milo = pb.milo,     diffusionmap = dm,     terminal_state = branch.tips,     diffusiontime = dif.pse[[paste0(\"DPT\", root)]],     root_cell = root,     pseudotime_key = \"pseudotime\" ) #> Sampling and flocking waypoints... #> Markov chain construction... #> Computing fundamental matrix and absorption probabilities... #> Project probabilites from waypoints to each pseudobulk...  # Project Pseudobulk Data projected_milo <- projectPseudotimeToCell(milo_object, pb.milo, branch.tips, pseudotime_key = \"pseudotime\") #> 3 number of cells removed due to not belonging to any neighbourhood"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/sce_vdj.html","id":null,"dir":"Reference","previous_headings":"","what":"Example Dataset for V(D)J Analysis — sce_vdj","title":"Example Dataset for V(D)J Analysis — sce_vdj","text":"sce_vdj object -sampled demo dataset derived Suo et al., 2024, Nature Biotechnology. dataset used vignettes demonstrate workflows V(D)J analysis. details, see original publication https://www.nature.com/articles/s41587-023-01734-7.","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/sce_vdj.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example Dataset for V(D)J Analysis — sce_vdj","text":"","code":"data(sce_vdj)"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/sce_vdj.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example Dataset for V(D)J Analysis — sce_vdj","text":"SingleCellExperiment object following slots: colData DataFrame containing metadata sample, corresponding obs AnnData (Python). following columns relevant vignette usage: productive_(mode)_VDJ, productive_(mode)_VJ Factors indicating whether heavy light chain productive. mode refers extraction mode V(D)J genes can one : 'abT': TCRαβ 'gdT': TCRγδ 'B': BCR Gene segment fields Gene segment annotations column names format (v/d/j)_call_(mode)_(VDJ/VJ). Examples include: v_call_abT_VDJ: V gene TCRαβ VDJ recombination d_call_abT_VJ: D gene TCRαβ VJ recombination chain_status factor describing receptor chain's status. anno_lvl_2_final_clean Cell type annotations. int_colData DataFrame containing additional assay metadata important analysis. Includes: X_scvi: dimensionality reduction matrix scVI model. UMAP: UMAP reduction matrix.","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/sce_vdj.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Example Dataset for V(D)J Analysis — sce_vdj","text":"Suo et al., 2024, Nature Biotechnology. https://www.nature.com/articles/s41587-023-01734-7.","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/sce_vdj.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Example Dataset for V(D)J Analysis — sce_vdj","text":"","code":"data(sce_vdj)"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/setupVdjPseudobulk.html","id":null,"dir":"Reference","previous_headings":"","what":"Preprocess V(D)J Data for Pseudobulk Analysis — setupVdjPseudobulk","title":"Preprocess V(D)J Data for Pseudobulk Analysis — setupVdjPseudobulk","text":"function preprocesses single-cell V(D)J sequencing data pseudobulk analysis. filters data based productivity chain status, subsets data, extracts main V(D)J genes, removes unmapped entries.","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/setupVdjPseudobulk.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Preprocess V(D)J Data for Pseudobulk Analysis — setupVdjPseudobulk","text":"","code":"setupVdjPseudobulk(   sce,   mode_option = c(\"abT\", \"gdT\", \"B\"),   already.productive = TRUE,   productive_cols = NULL,   productive_vj = TRUE,   productive_vdj = TRUE,   allowed_chain_status = NULL,   subsetby = NULL,   groups = NULL,   extract_cols = NULL,   filter_unmapped = TRUE,   check_vj_mapping = c(TRUE, TRUE),   check_vdj_mapping = c(TRUE, FALSE, TRUE),   check_extract_cols_mapping = NULL,   remove_missing = TRUE )"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/setupVdjPseudobulk.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Preprocess V(D)J Data for Pseudobulk Analysis — setupVdjPseudobulk","text":"sce SingleCellExperiment object. V(D)J data contained colData filtering. mode_option Optional character. Specifies mode extracting V(D)J genes. NULL, extract_cols must specified. Default NULL. already.productive Logical. Whether data already filtered productivity. TRUE, skips productivity filtering. Default FALSE. productive_cols Character vector. Names colData columns used productivity filtering. Default NULL. productive_vj Logical. TRUE, retains cells main VJ chain productive. Default TRUE. productive_vdj Logical. TRUE, retains cells main VDJ chain productive. Default TRUE. allowed_chain_status Character vector. Specifies chain statuses retain. Valid options include c('single pair', 'Extra pair', 'Extra pair-exception', 'Orphan VDJ', 'Orphan VDJ-exception'). Default NULL. subsetby Character. Name colData column subsetting. Default NULL. groups Character vector. Specifies subset condition filtering. Default NULL. extract_cols Character vector. Names colData columns V(D)J information stored, used instead standard columns. Default NULL. filter_unmapped Logic. Whether filter unmapped data. Default TRUE. check_vj_mapping Logic vector. Whether check VJ mapping. Default c(TRUE, TRUE). first element TRUE, function filter unmapped data V gene VJ chain second element TRUE, function filter unmapped data J gene VJ chain check_vdj_mapping Logic vector. Specifies columns check VDJ mapping. Default c(TRUE, FALSE, 'TRUE). first element TRUE, function filter unmapped data V gene VDJ chain second element TRUE, function filter unmapped data D gene VDJ chain third element TRUE, function filter unmapped data J gene VDJ chain check_extract_cols_mapping Character vector. Specifies columns related extract_cols mapping checks. Default NULL. remove_missing Logical. TRUE, removes cells contigs matching filter. FALSE, masks uniform values. Default TRUE.","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/setupVdjPseudobulk.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Preprocess V(D)J Data for Pseudobulk Analysis — setupVdjPseudobulk","text":"filtered SingleCellExperiment object","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/setupVdjPseudobulk.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Preprocess V(D)J Data for Pseudobulk Analysis — setupVdjPseudobulk","text":"function performs following preprocessing steps: Productivity Filtering: Skipped already.productive = TRUE. Filters cells based productivity using productive_cols standard colData columns named productive_{mode_option}_{type} (type 'VDJ' 'VJ'). mode_option function check colData(s) named productive_{mode_option}_{type}, type 'VDJ' 'VJ' , depending values productive_vj productive_vdj. set NULl, function needs option 'extract_cols' specified productive_cols must specified productivity filtering need conduct mode_option NULL. VDJ/VJ information stored used instead standard columns. productive_vj, productive_vdj TRUE, cell kept main V(D)J chain productive Chain Status Filtering: Retains cells chain statuses specified allowed_chain_status. Subsetting: Conducted subsetby groups provided. Retains cells matching groups condition subsetby column. Main V(D)J Extraction: Uses extract_cols specify custom columns extracting V(D)J information. Unmapped Data Filtering: decided removes masks cells based filter_unmapped. Checks specific columns unclear mappings using check_vj_mapping, check_vdj_mapping, check_extract_cols_mapping. filter_unmapped pattern filtered object. set NULL, filtering process start check_vj_mapping, check_vdj_mapping colData specified arguments (check_vj_mapping check_vdj_mapping) checked unclear mappings check_extract_cols_mapping, related extract_cols colData specified argument checked unclear mapping, colData first specified extract_cols remove_missing TRUE, remove cells contigs matching filter object. FALSE, mask uniform value dependent column name.","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/setupVdjPseudobulk.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Preprocess V(D)J Data for Pseudobulk Analysis — setupVdjPseudobulk","text":"","code":"# load data data(sce_vdj) # check the dimension dim(sce_vdj) #> [1] 33538 10000 # filtered the data sce_vdj <- setupVdjPseudobulk(     sce = sce_vdj,     mode_option = \"abT\", # set the mode to αβTCR     allowed_chain_status = c(\"Single pair\", \"Extra pair\"),     already.productive = FALSE ) # need to filter the unproductive cells #> Checking productivity from productive_abT_VDJ, productive_abT_VJ ... #> 7279 of cells filtered #> checking allowed chain status... #> 12 of cells filtered #> VDJ data extraction begin: #> Parameter extract_cols do not provided, automatically geneterate colnames for extraction. #> Detect whether colData v_call_abT_VDJ, d_call_abT_VDJ, j_call_abT_VDJ, v_call_abT_VJ, j_call_abT_VJ already exist... #> Extract main TCR from v_call_abT_VDJ, d_call_abT_VDJ, j_call_abT_VDJ, v_call_abT_VJ, j_call_abT_VJ ... #> Complete. #> Filtering cells from v_call_abT_VDJ_main, j_call_abT_VDJ_main, v_call_abT_VJ_main, j_call_abT_VJ_main ... #> 63 of cells filtered #> 2646 of cells remain. # check the remaining dim dim(sce_vdj) #> [1] 33538  2646"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/splitCTgene.html","id":null,"dir":"Reference","previous_headings":"","what":"Split the V(D)J genes from CTgene column and store them separately. — splitCTgene","title":"Split the V(D)J genes from CTgene column and store them separately. — splitCTgene","text":"Split V(D)J genes CTgene column store separately.","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/splitCTgene.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Split the V(D)J genes from CTgene column and store them separately. — splitCTgene","text":"","code":"splitCTgene(sce)"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/splitCTgene.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Split the V(D)J genes from CTgene column and store them separately. — splitCTgene","text":"sce SingleCellExperiment object conducting scRepertoire::combineTCR()","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/splitCTgene.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Split the V(D)J genes from CTgene column and store them separately. — splitCTgene","text":"list contain vector VJ & VDJ genes cell","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/vdjPseudobulk.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Pseudobulk V(D)J Feature Space — vdjPseudobulk","title":"Generate Pseudobulk V(D)J Feature Space — vdjPseudobulk","text":"function creates pseudobulk V(D)J feature space single-cell data, aggregating V(D)J information pseudobulk groups. supports input either Milo object SingleCellExperiment object.","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/vdjPseudobulk.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Pseudobulk V(D)J Feature Space — vdjPseudobulk","text":"","code":"vdjPseudobulk(   milo,   pbs = NULL,   col_to_bulk = NULL,   extract_cols = c(\"v_call_abT_VDJ_main\", \"j_call_abT_VDJ_main\", \"v_call_abT_VJ_main\",     \"j_call_abT_VJ_main\"),   mode_option = c(\"abT\", \"gdT\", \"B\"),   col_to_take = NULL,   normalise = TRUE,   renormalise = FALSE,   min_count = 1L )"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/vdjPseudobulk.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Pseudobulk V(D)J Feature Space — vdjPseudobulk","text":"milo Milo SingleCellExperiment object containing V(D)J data. pbs Optional. binary matrix cells rows pseudobulk groups columns. milo Milo object, parameter required. milo SingleCellExperiment object, either pbs col_to_bulk must provided. col_to_bulk Optional character character vector. Specifies colData column(s) generate pbs. multiple columns provided, combined. Default NULL. milo Milo object, parameter required. milo SingleCellExperiment object, either pbs col_to_bulk must provided. extract_cols Character vector. Specifies column names V(D)J information stored. Default c('v_call_abT_VDJ_main', 'j_call_abT_VDJ_main', 'v_call_abT_VJ_main', 'j_call_abT_VJ_main'). mode_option Character. Specifies mode extracting V(D)J genes. Must one c('B', 'abT', 'gdT'). Default 'abT'. Note: parameter considered extract_cols = NULL. NULL, uses column names v_call_VDJ instead v_call_abT_VDJ. col_to_take Optional character list characters. Specifies obs column(s) identify common value pseudobulk. Default NULL. normalise Logical. TRUE, scales counts V(D)J gene group 1 pseudobulk. Default TRUE. renormalise Logical. TRUE, rescales counts V(D)J gene group 1 pseudobulk removing 'missing' calls. Useful setupVdjPseudobulk() run remove_missing = FALSE. Default FALSE. min_count Integer. Sets pseudobulk counts V(D)J gene groups fewer many non-missing calls 0. Relevant normalise = TRUE. Default 1.","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/vdjPseudobulk.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Pseudobulk V(D)J Feature Space — vdjPseudobulk","text":"SingleCellExperiment object","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/vdjPseudobulk.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Pseudobulk V(D)J Feature Space — vdjPseudobulk","text":"function aggregates V(D)J data pseudobulk groups based following logic: Input Requirements: milo Milo object, neither pbs col_to_bulk required. milo SingleCellExperiment object, user must provide either pbs col_to_bulk. Normalization: normalise = TRUE, scales V(D)J counts 1 pseudobulk group. renormalise = TRUE, rescales counts removing 'missing' calls. Mode Selection: extract_cols = NULL, function relies mode_option determine V(D)J columns extract. Filtering: Uses min_count filter pseudobulks insufficient counts V(D)J groups.","code":""},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/reference/vdjPseudobulk.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Pseudobulk V(D)J Feature Space — vdjPseudobulk","text":"","code":"data(sce_vdj) sce_vdj <- setupVdjPseudobulk(sce_vdj,     already.productive = FALSE,     allowed_chain_status = c(\"Single pair\", \"Extra pair\") ) #> Checking productivity from productive_abT_VDJ, productive_abT_VJ ... #> 7279 of cells filtered #> checking allowed chain status... #> 12 of cells filtered #> VDJ data extraction begin: #> Parameter extract_cols do not provided, automatically geneterate colnames for extraction. #> Detect whether colData v_call_abT_VDJ, d_call_abT_VDJ, j_call_abT_VDJ, v_call_abT_VJ, j_call_abT_VJ already exist... #> Extract main TCR from v_call_abT_VDJ, d_call_abT_VDJ, j_call_abT_VDJ, v_call_abT_VJ, j_call_abT_VJ ... #> Complete. #> Filtering cells from v_call_abT_VDJ_main, j_call_abT_VDJ_main, v_call_abT_VJ_main, j_call_abT_VJ_main ... #> 63 of cells filtered #> 2646 of cells remain. # Build Milo Object milo_object <- miloR::Milo(sce_vdj) milo_object <- miloR::buildGraph(milo_object, k = 50, d = 20, reduced.dim = \"X_scvi\") #> Constructing kNN graph with k:50 milo_object <- miloR::makeNhoods(milo_object, reduced_dims = \"X_scvi\", d = 20) #> Checking valid object #> Running refined sampling with reduced_dim  # Construct pseudobulked VDJ feature space pb.milo <- vdjPseudobulk(milo_object, col_to_take = \"anno_lvl_2_final_clean\")"},{"path":"https:/tuonglab.github.io/dandelionR/preview/pr40/news/index.html","id":"dandelionr-version-0990-2024-12-12","dir":"Changelog","previous_headings":"","what":"dandelionR Version 0.99.0 (2024-12-12)","title":"dandelionR Version 0.99.0 (2024-12-12)","text":"First working version package.","code":""}]
